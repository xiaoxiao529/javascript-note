<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
	<link rel="stylesheet" type="text/css" href="https://cdn.bootcss.com/bootstrap/4.0.0/css/bootstrap.min.css"/>
	<title>javascript学习</title>
	<script src="http://libs.baidu.com/jquery/2.0.0/jquery.min.js"></script>
</head>
	<body>

		笔记
		
		1、相等运算符
		== 在比较之前，会自动转换数据类型再进行比较。
		=== 不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再进行比较。
		注意：不要使用==进行比较，坚持使用===进行比较
		
		
		2、null undefined
		null：表示一个“空”的值
		undefined：表示“未定义”
		区分2者意义不大，大多数情况下使用null。undefined仅仅在判断函数参数是否传递的情况下有用。
		
		3、数组
		数组：一组按照顺序排列的集合，集合的每个元素称之为元素
		var arr = [1,2,3,"hello",null,true];  数组元素可以包括任意数据类型
		数组通过索引值访问，索引值从0开始
		
		(1)、length值可以获取数组的长度
		设置 length 属性可改变数组的大小。如果设置的值比其当前值小，数组将被截断，其尾部的元素将丢失。
		如果设置的值比它的当前值大，数组将增大，新的元素被添加到数组的尾部，它们的值为 undefined。
		
		(2)、indexOf
		与字符串类似，通过indexOf来搜索一个指定元素的位置
		
		(3)、slice
		slice(start,end)对应字符串的substring(start,end)，截取数组[start,end-1]之间的元素，然后返回一个新的数组
		
		如果不给slice传递任何参数，那么就会从头到尾截取数组，利用这一点可以快速复制一个数组
		
		(4)、push和pop
		push()，向数组末尾添加数据
		pop()，把数组最后一个元素删除
		
		(5)、shift和unshift
		unshift()，向数组头部添加数据
		shift()，把数组第一个元素删除
		
		(6)、sort
		sort()，对当前数组进行排序
		['Google', 'Apple', 'Microsoft'].sort(); // ['Apple', 'Google', 'Microsoft'];
		
		(7)、reverse
		reverse()，将数组进行反转
		
		(8)、splice
		splice()，向数组中添加/删除元素，然后返回被删除的元素（如果有的话）
		该方法会改变原始数组
		arr.splice(index,howmany,item);
		index——添加/删除元素的位置
		howmany——要删除的元素数量，如果为0，则不删除
		item——替换索引处的元素，howmany为0则是在索引处添加，howmany不为0则是先删除索引处的元素然后在该位置放进去这个item
		
		(9)、concat
		concat()，链接多个数组，返回一个新数组
		
		(10)、join
		join()，将数组的每个元素用指定的字符串连接，然后返回连接后的字符串
		
		
		
		
		
		
		
		
		
		
		4、对象
		对象：一组由键值对组成的无序集合
		var person = {
		    name: 'Bob',
		    age: 20,
		    tags: ['js', 'web', 'mobile'],
		    city: 'Beijing',
		    hasCar: true,
		    zipcode: null,
		    
		};
		
		★★ 键都是字符串类型，值可以是任意数据类型
		
		
		访问属性使用.操作符，前提是属性名必须是一个有效的变量名。
		如果属性名包含特殊字符，那么就得用""括起来，访问的时候使用obj.["xxx"]来访问
		var xiaohong = {
		    name: '小红',
		    'middle-school': 'No.1 Middle School'
		};
		xiaohong['middle-school']; // 'No.1 Middle School'
		xiaohong['name']; // '小红'
		xiaohong.name; // '小红'
		
		★★
		检测对象是否具有某一属性，可以使用in操作符
		var xiaoming = {
		    name: '小明',
		    birth: 1990,
		    school: 'No.1 Middle School',
		    height: 1.70,
		    weight: 65,
		    score: null
		};
		'name' in xiaoming; // true
		'grade' in xiaoming; // false
		
		注意，使用in操作符判断一个属性存在，这个属性不一定就是xiaoming的，它有可能是xiaoming继承得到的
		'toString' in xiaoming //true
		
		因为toString定义在object对象中，而所有对象最终都会在原型链上指向object，所以xiaoming也拥有toString属性。
		要判断一个属性是否是xiaoming自身拥有的，而不是继承得到的，可以用hasOwnProperty()方法：
		
		var xiaoming = {
		    name: '小明'
		};
		xiaoming.hasOwnProperty('name'); // true
		xiaoming.hasOwnProperty('toString'); // false
		
		
		
		
		5、始终使用var声明变量，如果一个变量没有通过var声明就被使用，那么该变量就自动被声明为全局变量。
		使用var声明的变量是局部变量，它的使用范围被限制在该变量被声明的函数体内
		同名变量在不同的函数体内互不冲突。
		
		6、字符串
		"" ''
		
		es6语法：多行字符串 ` `这个来表示，不用+来拼接了。
		
		模板字符串
		多个变量需要拼接，可以使用+
		如：
		var name = "小敏";
		var age = 20;
		var message = "你好，"+ name + "你今年" + age + "岁了！";
		
		es6语法：模板字符串
		var name = "小敏";
		var age = 20;
		var message = "你好,${name},你今年${age}岁了！";
		
		★★★★★重点：
		字符串常见的操作方法，注意这些方法不会改变原有字符串的内容，而是返回一个新字符串
		
		★★★★★重点
		字符串是不可变的，这一点和数组不一样
		对字符串的某个索引值赋值，不会有任何错误，但是也没有任何效果
		var s = "text";
		s[0]="x";
		alert(s);//仍然是"text"
		
		(1)、获取字符串某个位置的字符，使用类似Array的下标操作，索引号从0开始
		var s = "hello,world";
		s[0];  //"h"
		
		(2)、indexOf
		搜索指定字符串出现的位置，找不到返回-1
		
		(3)、charAt
		返回指定位置的字符(长度为1的字符串)
		str.charAt(index);  //index的取值范围是[0,str.length-1]
		
		(4)、charCodeAt
		返回指定位置的字符串的Unicode编码。返回值在0-65535之间的整数
		str.charCodeAt(index);  //
		小例子：输入框只许输入数字
		
		0-9的Unicode编码：48-57
		
		(5)、substring
		返回指定索引之间的字符串，不写end则一直到结尾
		str.substring(start,end);  //2个参数都是正数，返回start到end-1之间的字符串
		
		(6)、slice
		返回指定索引之间的字符串，不写end则一直到结尾
		str.slice(start,end);  //2个参数可正可负，返回start到end-1之间的字符串
		
		(7)、split
		把字符串分割为数组
		str.split(separator,howmany); //以separator作为分割参考对象，返回一个数组
		
		(8)、substr——不建议使用，没有标准化
		返回从start开始指定数目的字符串
		str.substring(start,length);  //length是返回的字符串的长度，可选，不写则一直返回到结尾
		
		
		
		7、条件判断 if-else
		
		JavaScript把null、undefined、0、NaN和空字符串''视为false，其他值一概视为true
		
		
		8、Map
		一组键值对的结构，具有极快的查找速度
		
		var m = new Map();//空map
		var m = new Map([['Michael',95],['kate',76],['Tracy',56]]);
		console.log(m.get("kate"));
		m.set('xx','100');
		console.log(m.get("xx"));
		m.delete("xx");
		console.log(m.get("xx"));
		
		由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：
		var m = new Map();
		m.set('Adam', 67);
		m.set('Adam', 88);
		m.get('Adam'); // 88
		
		
		9、Set
		和Map类似，是一组key的集合，不存储value。由于key不能重复，所以，在Set中没有重复的key
		重复元素在Set中自动被过滤
		要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set：
		var set = new Set();//空set
		var set = new Set([1,2,3]);
		
		10、函数
		
		函数声明法
		function abs(x) {
		    if (x >= 0) {
		        return x;
		    } else {
		        return -x;
		    }
		}
		
		函数字面量表示法
		var abs = function(x){
			if (x >= 0) {
		        return x;
		    } else {
		        return -x;
		    }
		};  //在函数体末尾加一个;，表示赋值语句结束。
		
		★	由于js的函数也是一个对象，上述定义的abs()函数实际上是一个函数对象，而函数名abs可以视为指向该函数的变量，并且被绑定到window对象
		
		请注意，函数体内部的语句在执行时，一旦执行到return时，函数就执行完毕，并将结果返回。
		如果没有return语句，函数执行完毕后也会返回结果，只是结果为undefined。
		
		★ arguments
		
		只在函数内部起作用，并且永远的指向当前函数的调用者传入的所有参数，arguments类似于Array，但不是Array
		
		11、变量作用域与解构赋值
		
		js函数可以嵌套
		内部函数的变量可以访问外部函数定义的变量，反过来就不行
		如果内部函数和外部函数的变量重名，那么内部函数的变量将“屏蔽”外部函数的变量
		
		★变量提升
		在函数内部，不管变量在什么位置定义，都会把申明的变量提升到函数的最顶部。这时候可能只是定义了函数，但是没有赋值，此时值为undefined
		
		由于JavaScript的这一怪异的“特性”，我们在函数内部定义变量时，请严格遵守“在函数内部首先申明所有变量”这一规则。
		最常见的做法是用一个var申明函数内部用到的所有变量
		
		
		function fn1(){
			var x=1,y=2,z=3;
			...
		}
		
		★全局作用域
		不在任何函数内定义的变量就就有全局作用域
		实际上，js默认有一个全局对象window，全局作用域的变量实际上被绑定到为window的一个属性
		var course = "js";
		alert(course) === alert(window.course)
		
		★方法
		在一个对象中绑定函数，这个函数称为对象的方法
		
		★★this关键字
		在一个方法内部，this是一个特殊变量，它始终指向当前对象

		定义在函数内部的this，指向调用这个方法的对象
		定义在函数内部的函数的this，就不是指向调用这个方法的对象了，而是指向window
		可以使用var that = this;然后在函数内部的函数中使用that来进行指代
		
		
		★apply
		控制this指向的问题
		
		接受2个参数，第一个是需要绑定的this变量(也就是决定this到底指向那个对象，不需要加引号)，第二个参数是Array，表示函数本身的参数。
		
		★call
		控制this指向的问题
		接受2个参数，第一个是需要绑定的this变量(也就是决定this到底指向那个对象)，第二个参数表示函数本身的参数，不再是Array，而是按顺序传入参数。
		getAge.call(xiaoming,2,3,4);  //3个参数
		
		举例：
		调用Math.max(3,5,4);
		Math.max.apply(null,[3,5,4]);  //5
		Math.call.apply(null,3,5,4);  //5
		
		P.S.对普通函数调用，通常把this绑定为null
		
		
		
		12、高阶函数
		一个函数可以接收另一个函数作为参数，那么这种函数就称之为高阶函数
		编写高阶函数，就是让函数的参数能够接收别的函数
		
		★★map函数
		就是一个典型的高阶函数
		Array.map()
		map是Array对象下面的方法，返回一个新数组，数组中的元素为原始数组元素调用函数(也就是map的参数中的函数)处理后的值。
		
		
		★★reduce函数
		Array.reduce()
		把一个函数作用在这个Array的每一项元素上，x1,x2...，这个函数必须接收2个参数，reduce()把结果(可以是累加、累乘等加减运算)继续和序列的下一个元素做累积计算
		
		★★filter函数
		Array.filter()
		用于把Array的某些元素过滤掉，返回剩下的元素
		filter()把传入的函数依次作用于每个元素，然后根据返回值是true还是false决定保留还是丢弃该元素
		
		★★sort函数
		Array.sort()
		排序算法
		
		
		13、闭包
		函数作为返回值
		高阶函数除了可以接受函数作为参数之外，还可以把函数作为结果值返回
		
		
		14、箭头函数		
		箭头函数，相当于匿名函数，并且简化了函数定义。
		
		(1)、只包含一个表达式的，省略{...}和return
		x => x*x  等价于
		function(x){
			return x*x;
		}
		
		(2)、包含多条语句，这时候不能省略{...}和return
		x => {
			if(x>0){
				return x*x;
			}else{
				return -x*x;
			}
		}
		
		★★扩展：es6的扩展运算符和rest参数
		
		扩展运算符，功能是把数组或类数组对象展开成一系列用逗号隔开的值
		形式为：...
		
		
		
		15、标准对象
		在js的世界里，一切都是对象
		
		★★注意点：
		
		不要使用new Number()、new Boolean()、new String()创建包装对象；

		用parseInt()或parseFloat()来转换任意类型到number；
		
		用String()来转换任意类型到string，或者直接调用某个对象的toString()方法，null和undefined没有toString()方法；
		
		通常不必把任意类型转换为boolean再判断，因为可以直接写if (myVar) {...}；
		
		typeof操作符可以判断出number、boolean、string、function和undefined；
		
		判断Array要使用Array.isArray(arr)；
		
		判断null请使用myVar === null；
		
		判断某个全局变量是否存在，用typeof window.myVar === 'undefined'；
		
		函数内部判断某个变量是否存在，用typeof myVar === 'undefined'。
		
		number调用toString()方法报错
		123.toString();  //SyntaxError
		这样处理一下：
		123..toString(); // '123', 注意是两个点！
		(123).toString(); // '123'
		
		
		16、Date对象
		
		17、RegExp对象
		
		18、JSON
		
		将对象序列化成JSON格式字符串
		var str = {}
		JSON.stringify(str);
		
		将JSON格式字符串转化为js对象
		JSON.parse('[1,2,3,true]'); // [1, 2, 3, true]
		JSON.parse('{"name":"小明","age":14}'); // Object {name: '小明', age: 14}
		JSON.parse('true'); // true
		JSON.parse('123.45'); // 123.45
		
		调用接口将返回的json数据按原样塞入
		<div>  
		    <pre id = "show">  
		    </pre>  
		</div>  
		
		然而接收到的json串不能直接通过 $("#show").html(jsObj) 塞进去，
		
		需要用JSON.stringify（）转为字符串才能作为内容填充进去，如果要格式化显示，则要在转为string时添加参数：
		JSON.stringify(jsObj, null, "\t"); // 缩进一个tab    
		JSON.stringify(jsObj, null, 4);    // 缩进4个空格    
		
		
		19、面向对象编程
		
		创建对象
		方法一：
		var robot = {
		    name: 'Robot',
		    height: 1.6,
		    run: function () {
		        console.log(this.name + ' is running...');
		    }
		};
		
		方法二：
		构造函数方法来创建对象
		function Student(name){
			this.name = name;
			this.hello = function(){
				console.log('hello'+this.name);
			}
		}
		var xm = new Student('小明');
		xm.hello();
		
		★★注意：
		如果不写new，这就是一个普通函数，它返回undefined。但是，如果写了new，它就变成了一个构造函数，它绑定的this指向新创建的对象，并默认返回this，
		也就是说，不需要在最后写return this;
		
		20、浏览器
		
		window对象下的属性：
		innerWidth、innerHeight：获取浏览器窗口的内部宽度和高度。内部宽高是指除去菜单栏、工具栏、边框等占位元素后，用于显示网页的净宽高。
		outerWidth、outerHeight、screen.width、screen.height:都表示电脑显示屏的大小
		
		document对象
		表示当前页面。由于HTML在浏览器中以DOM形式表示为树形结构，document对象就是整个DOM树的根节点。
		
		
		<script type="text/javascript">
			console.log(document.cookie);
		</script>
		
		操作DOM
		
		innerHTML：不但可以修改一个DOM节点的文本内容，还可以直接通过HTML片段修改DOM节点内部的子树，注意要对字符串进行编码来避免XSS攻击
		下面2个函数可以自动对字符串进行HTML编码，保证无法设置任何HTML标签
		两者的区别在于读取属性时，innerText不返回隐藏元素的文本，而textContent返回所有文本。另外注意IE9以下不支持textContent
		innerText：
		textContent
		
		
		21、AJAX
		http://api.money.126.net/data/feed/0000001,1399001?callback=refreshPrice
		
		22、jQuery
		
		★ text()、html()
		分别获取节点的文本和原始HTML文本
		<!-- HTML结构 -->
		<ul id="test-ul">
		    <li name="book">Java &amp; JavaScript</li>
		</ul>
		
		分别获取文本和HTML：
		
		$('#test-ul li[name=book]').text(); // 'Java & JavaScript'
		$('#test-ul li[name=book]').html(); // 'Java &amp; JavaScript'
		
		无参数调用text()是获取文本，传入参数就变成设置文本，HTML也是类似操作
		
		★ attr()、prop()
		对于属性checked的处理有所不同
		var radio = $('#test-radio');
		radio.attr('checked'); // 'checked'
		radio.prop('checked'); // true
		
		prop()返回值更合理一些。不过，用is()方法判断更好：

		var radio = $('#test-radio');
		radio.is(':checked'); // true
		类似的属性还有selected，处理时最好用is(':selected')。
		
		★ append()、prepend()
		添加新的DOM节点
		除了接受字符串，append()还可以传入原始的DOM对象，jQuery对象和函数对象
		append()把DOM添加到最后，prepend()则把DOM添加到最前。
		
		★ after()、before()
		同级节点可以用after()或者before()方法。
		
		remove()
		要删除DOM节点，拿到jQuery对象后直接调用remove()方法就可以了。如果jQuery对象包含若干DOM节点，实际上可以一次删除多个DOM节点：
		
		<hr />
		<div><input type="text" name="inp01" id="input01" value="" /></div>
		
		★ get(index)函数
		获取当前jQuery对象匹配到的其中某一个DOM元素，具体哪一个根据参数index来决定
		如果没有为get()函数指定参数index，则返回包含所有匹配到的元素的数组；如果指定了索引参数index，则只获取对应索引的那个元素。
		
		
		
		23、编写jQuery插件
		
		给jQuery对象绑定一个新方法是通过扩展$.fn对象实现的
		最终，我们得出编写一个jQuery插件的原则：

		(1)、给$.fn绑定函数，实现插件的代码逻辑；
		(2)、插件函数最后要return this;以支持链式调用；
		(3)、插件函数要有默认值，绑定在$.fn.<pluginName>.defaults上；
		(4)、用户在调用时可传入设定值以便覆盖默认值。
		
		$.fn.myPlugin = function() {
		    //在这里面,this指的是用jQuery选中的元素，一般是一个jQuery类型的集合
		    //example :$('a'),则this=$('a')
		    this.css('color', 'red');
		}
		
		★面向对象的插件开发
		为什么要有面向对象的思维，因为如果不这样，你可能需要一个方法的时候就去定义一个function，当需要另外一个方法的时候，再去随便定义一个function，
		同样，需要一个变量的时候，毫无规则地定义一些散落在代码各处的变量。
		还是老问题，不方便维护，也不够清晰。当然，这些问题在代码规模较小时是体现不出来的。

		如果将需要的 重要变量定义到对象的属性上，函数变成对象的方法，当我们需要的时候通过对象来获取，
		一来方便管理，二来不会影响外部命名空间，因为所有这些变量名还有方法名都是在对象内部。
		
		不到万不得已，一般我们不会将变量定义成全局的
		一个好的做法是始终用 自调用匿名函数 包裹你的代码，
		这样就可以完全放心，安全地将它用于任何地方了，绝对没有冲突。
		还有一个好处就是，自调用匿名函数里面的代码会在第一时间执行，页面准备好过后，上面的代码就将插件准备好了，以方便在后面的代码中使用插件。
		
		我们用来充当自调用匿名函数的第一对括号与上面别人定义的函数相连，因为中间没有分号嘛，总之我们的代码无法正常解析了，所以报错。
		所以好的做法是我们在代码开头加一个分号，这在任何时候都是一个好的习惯。

		var foo=function(){
		    //别人的代码
		}//注意这里没有用分号结尾
		
		//开始我们的代码。。。
		;(function(){
		    //我们的代码。。
		    alert('Hello!');
		})();
		
		
		同时，将系统变量以参数形式传递到插件内部也是个不错的实践。
		当我们这样做之后，window等系统变量在插件内部就有了一个局部的引用，可以提高访问速度，会有些许性能的提升
		最后我们得到一个非常安全结构良好的代码：
		;(function($,window,document,undefined){
		    //我们的代码。。
		    //blah blah blah...
		})(jQuery,window,document);
		
		
		关于变量定义及命名
		现在谈谈关于变量及方法等的命名，没有硬性规定，但为了规范，遵循一些约定还是很有必要的。
		
		变量定义：好的做法是把将要使用的变量名用一个var关键字一并定义在代码开头，变量名间用逗号隔开。原因有二：
		
		一是便于理解，知道下面的代码会用到哪些变量，同时代码显得整洁且有规律，也方便管理，变量定义与逻辑代码分开；
		二是因为JavaScript中所有变量及函数名会自动提升，也称之为JavaScript的Hoist特性，即使你将变量的定义穿插在逻辑代码中，
		在代码解析运行期间，这些变量的声明还是被提升到了当前作用域最顶端的，所以我们将变量定义在一个作用域的开头是更符合逻辑的一种做法。
		当然，再次说明这只是一种约定，不是必需的。
		变量及函数命名 一般使用驼峰命名法（CamelCase），即首个单词的首字母小写，后面单词首字母大写，比如resultArray，requestAnimationFrame。
		对于常量，所有字母采用大写，多个单词用下划线隔开，比如WIDTH=100，BRUSH_COLOR='#00ff00'。
		当变量是jQuery类型时，建议以$开头，开始会不习惯，但经常用了之后会感觉很方便，因为可以很方便地将它与普通变量区别开来，
		一看到以$开头我们就知道它是jQuery类型可以直接在其身上调用jQuery相关的方法，比如var $element=$('a'); 
		之后就可以在后面的代码中很方便地使用它，并且与其他变量容易区分开来。
		
		引号的使用：既然都扯了这些与插件主题无关的了，这里再多说一句，一般HTML代码里面使用双引号，而在JavaScript中多用单引号，比如下面代码所示：
		
		var name = 'Wayou';
		document.getElementById(‘example’).innerHTML = '< a href="http: //wayouliu.duapp.com/">'+name+'</a>'; //href=".." HTML中保持双引号，JavaScript中保持单引号
		 
		
		一方面，HTML代码中本来就使用的是双引号，另一方面，在JavaScript中引号中还需要引号的时候，要求我们单双引号间隔着写才是合法的语句，除非你使用转意符那也是可以的。
		再者，坚持这样的统一可以保持代码风格的一致，不会出现这里字符串用双引号包着，另外的地方就在用单引号。
		
		
		24、错误处理
		涉及到异步代码，无法在调用时捕获，原因就是在捕获的当时，回调函数并未执行。
		类似的，当我们处理一个事件时，在绑定事件的代码处，无法捕获事件处理函数的错误。
		
		★★异步代码只能在函数内部捕获错误
		
		
		$btn.click(function () {
		   try {
		        var
		            x = parseFloat($('#x').val()),
		            y = parseFloat($('#y').val()),
		            r;
		        if (isNaN(x) || isNaN(y)) {
		            throw new Error('输入有误');
		        }
		        r = x + y;
		        alert('计算结果：' + r);
	       } catch (e) {
	          	alert('输入有误！');
	       }
    	});
		
		
		25、Node.js
		npm：Node.js的包管理工具（node package manager）。
		为啥我们需要一个包管理工具呢？因为我们在Node.js上开发时，会用到很多别人写的JavaScript代码。
		如果我们要使用别人写的某个包，每次都根据名称搜索一下官方网站，下载代码，解压，再使用，非常繁琐。
		于是一个集中管理的工具应运而生：大家都把自己开发的模块打包后放到npm官网上，如果要使用，直接通过npm安装就可以直接用，不用管代码存在哪，应该从哪下载。
		更重要的是，如果我们要使用模块A，而模块A又依赖于模块B，模块B又依赖于模块X和模块Y，npm可以根据依赖关系，把所有依赖的包都下载下来并管理起来。
		否则，靠我们自己手动管理，肯定既麻烦又容易出错。
		
		
		★第一个Node程序
		在前面的所有章节中，我们编写的JavaScript代码都是在浏览器中运行的，因此，我们可以直接在浏览器中敲代码，然后直接运行。

		从本章开始，我们编写的JavaScript代码将不能在浏览器环境中执行了，而是在Node环境中执行，因此，JavaScript代码将直接在你的计算机上以命令行的方式运行，
		所以，我们要先选择一个文本编辑器来编写JavaScript代码，并且把它保存到本地硬盘的某个目录，才能够执行。
		
		
		在计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来越不容易维护。
		为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。
		
		在Node环境中，一个.js文件就称之为一个模块（module）。
		
		使用模块有什么好处？
		最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。
		我们在编写程序的时候，也经常引用其他模块，包括Node内置的模块和来自第三方的模块。
		使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。
		
		★CommonJS规范
		
		一个模块想要对外暴露变量（函数也是变量），可以用module.exports = variable;
		一个模块要引用其他模块暴露的变量，用var ref = require('module_name');就拿到了引用模块的变量。

		★基本模块
		因为Node.js是运行在服务区端的JavaScript环境，服务器程序和浏览器程序相比，最大的特点是没有浏览器的安全限制了，
		而且，服务器程序必须能接收网络请求，读写文件，处理二进制内容，所以，Node.js内置的常用模块就是为了实现基本的服务器功能。
		这些模块在浏览器环境中是无法被执行的，因为它们的底层代码是用C/C++在Node.js运行环境中实现的。
		
		global：Node.js的唯一全局对象
		window: 浏览器的全局对象
		
		★Node.js内置的常用模块
		
		fs模块：文件系统模块，负责读写文件
		和所有其它JavaScript模块不同的是，fs模块同时提供了异步和同步的方法。
		
		同步是：一条线从上到下按顺序执行代码，下面的代码等待上面的代码执行完然后才执行
		异步：执行到某一点之后，该点可能会返回什么结果(无论是否返回)，不影响后续代码的执行
		
		异步读文本文件：
		var fs = require('fs');  //
		fs.readFile('1.txt','utf-8',function(err,data){
			if(err){
				console.log(err);
			}else{
				console.log(data);  //hello world，first node
			}
		})

		读取文件简化就是：
		if (err) {
		    // 出错了
		} else {
		    // 正常
		}
		
		异步读二进制文件：
		
		
		
		
		
		
		
		
		
		<!-- HTML结构 -->
		<div id="test-div">
		    <ul>
		        <li><span>JavaScript</span></li>
		        <li><span>Python</span></li>
		        <li><span>Swift</span></li>
		    </ul>
		</div>
		
		
		
		<script>
			var person = {
			    name: 'Bob',
			    age: 20,
			    tags: ['js', 'web', 'mobile'],
			    city: 'Beijing',
			    hasCar: true,
			    zipcode: null
			};
			console.log(person.age);  //20
			console.log(person["hasCar"]);  //true
			
			var s = "hello,world";
			console.log(s.indexOf("rld"));  //8
			
			/*判断键盘的键位*/
			function keyKode(){
				window.onkeyup = function(ev){
					console.log(ev.keyCode)
				}
			}
			//keyKode();
			/*例子之只能输入数字*/
			var input01 = document.getElementById("input01");
			function detectNum(str){
				var unicodeNum=0;
				for (var i=0;i<str.length;i++) {
					unicodeNum = str.charCodeAt(i);
					if(unicodeNum>57 || unicodeNum<48){
						return false;  //函数结束执行
					}
				}
				return true;
			}
			input01.onblur = function(){
				var input01Val = input01.value;
				if(detectNum(input01Val)){
					console.log("正确")
				}else{
					console.log("错误")
				}
			}
			
			var str01 = "hello,world";
			console.log(str01.substr(1,5));
			
			console.log(str01.split('h'));
			
			var arr01 = [10,'a', 50, '30', 'xyz'];
			var arr02 = [8,7,9,4,6,'a','z','b'];
			console.log(arr01.slice(1,7));
			console.log(arr02.sort());
			
			var arr03 = [[1, 2, 3], [400, 500, 600], '-'];
			var x = arr03.slice(1,2);
			console.log(x[0][1]);
			
			var arr04 = ['小明','小红','大军','阿黄'];
			var s1 = arr04.slice(0,3).join(",");
			var s2 = arr04.sort().pop();
			console.log("欢迎"+s1+"和"+s2+"同学！");

			//console.log("欢迎"+arr04.slice(0,3).join(",")+"和"+arr04[3]+"同学！");
			
			
			var m = new Map([['Michael',95],['kate',76],['Tracy',56]]);
			console.log(m.get("kate"));
			m.set('xx','100');
			console.log(m.get("xx"));
			m.delete("xx");
			console.log(m.get("xx"));
			
			
			var set = new Set([1,2,3,'3',3]);
			console.log(set);
			set.add(4);
			console.log(set);
			set.delete('3');
			console.log(set);
			var newK = [4,5];
			set.add(newK);
			
			console.log(set.delete(newK));
			
			
			function foo(x){
				console.log(x);
				for (var i=0;i<arguments.length;i++) {
					console.log(arguments[i]);
				}
			}
			foo(10,20,30);
			
			function fn02(){ //单线程，先循环结束，再执行下面的代码
				for (var i=1;i<11;i++) {
					console.log(i);
				}
				console.log(i);
			}
			fn02();
			
			function getAge(){
				var y =new Date().getFullYear();
				return y-this.birth;
			}
			
			var xiaoming = {
				name:"xiaoming",
				birth:1990,
				getAge:getAge
			}
			
			console.log(xiaoming.getAge());
			console.log(getAge.apply(xiaoming,[]));
			
			
			/*重新改些parseInt函数*/
			var piNum = 0;
			var oldParseInt = parseInt;  //保存原函数，因为不知道原函数是怎么实现的，直接保存直接拿来用，不用去管内部实现原理
			window.parseInt = function(){
				piNum++;
				return oldParseInt.apply(null,arguments);
			}
			console.log(parseInt("18999cdsvf"));
			parseInt("1");
			parseInt("1");
			console.log(piNum);
			
			
			/*高阶函数*/
			function add(x,y,f){
				return f(x)+f(y);
			}
			console.log(add(-5,6,Math.abs));
			
			/*map方法*/
			function pow(x){
				return x*x;
			}
			var mapArray = [1,2,3,4,5];
			console.log(mapArray.map(pow));
			
			/*reduce方法*/
			var reduceArray = [1,2,3,4,5];
			console.log(reduceArray.reduce(function(x,y){
				return x+y;
			}))
			
			
			/*自己实现parseInt()方法*/
			function string2int(s) {
			   return s.split("").map(function(z){
			   	return z*1
			   }).reduce(function(x,y){
			   		return x*10+y;
			   });
			}
			console.log(string2int("12345"));
			
			/*规范字母显示*/
			function normalize(arr) {
			    return arr.map(function(x){
			    	return x.charAt(0).toUpperCase()+x.slice(1).toLowerCase();
			    });
			}
			console.log(normalize(['adam', 'LISA', 'barT']));
			
			/*sort排序*/
			var sortArray = [1,4,3,6,7];
			function compareSort(x,y){  //正序排列，大的数在后面，所以y-x>0
				if(x>y){
					return 1;  //正数交换
				}else if(x<y){
					return -1;  //负数不交换
				}else{
					return 0;
				}
			}
			console.log(sortArray.sort(compareSort));
			
			/*扩展运算符*/
			let karr = [1,2,3,4,5];
			let karr_ = [...karr,6,7];
			console.log(karr_);
			
			var xiaoming = {
				name:"小明",
				age:20
			}
			var s = JSON.stringify(xiaoming);
			console.log(s);  //{"name":"小明","age":20}
			console.log(JSON.parse('{"name":"小明","age":14}'))
			
			function Student(name){
				this.name = name;
				this.hello = function(){
					console.log('hello'+this.name);
				}
			}
			var xm = new Student('小明');
			xm.hello();
			
			console.log("2"|| undefined);

//			var ul = $('#test-div ul');
//			ul.append('<li><span>Pascal</span></li>','<li><span>Lua</span></li>','<li><span>Ruby</span></li>');
//			var aLi = ul.find('li');
//			var Darr = [];
//			aLi.each(function(i,elem){
//				Darr.push($(elem).find("span").html());
//			})
//			var newDarr = Darr.sort();
//			ul.empty();
//			for (let i of newDarr) {
//				ul.append('<li><span>'+i+'</span></li>')
//			}
//			document.write(ul);


		</script>
		
		
		
	</body>
</html>